# Как дублировать звук с Linux на Windows

## 1. Вступление
Думаю, стоит начать с того, зачем это вообще мне было нужно.
Уже давно для реализации некоторых своих проектов я хотел купить мини ПК и почти сразу же мне пришла в голову идея о том чтобы дублировать звук с мини ПК на основную машину. Мне показалось, это достаточно удобное и интересное решение в плане производительности. Ты спокойно можешь запустить что-то в браузере на мини-ПК, а на основной машине просто будет воспроизводиться звук. Звучит круто, когда нагрузка с браузера ложится на мини-ПК, а не на основную машину. И в целом удобно что-то смотреть на втором мониторе, даже если этот монитор подключён к мини-ПК.

### Немного о моем железе/системе
- Orange Pi Zero 2W на 4 гига
- Orange Pi Expansion Board для удобства как раз имеет usb под мышь и клавиатуру
- Ubuntu, я попробовал несколько официальных образов для Orange Pi. Orange Pi OS(Arch), Debian, Ubuntu
  
## 2. Бесконечные пробы и ошибки
Как человек, не имеющий большого опыта в Linux-системах и программировании под них, я полез спрашивать у нейросети как можно такое реализовать.
Было предложено пустить rtp поток на linux и ловиль его через VLC на windows. На словах просто на деле ничего не работает. Пробовал реализации и через PulseAudio, и через PipeWire, но никак не удалось пустить этот RTP.

### Примеры от нейронки
(pulseaudio)
```
pactl load-module module-null-sink sink_name=rtp

pactl load-module module-loopback sink=rtp

pactl load-module module-rtp-send source=rtp.monitor destination=224.0.0.56 port=5004
```
```
rtp://@:5004
```
(pipewire)
```
pactl load-module module-rtp-send source=rtp.monitor destination=224.0.0.56 port=5004 format=s16be rate=44100 channels=2
```
```
rtp://@:5004
```

## 3. Более-менее рабочие варианты

Из того что хоть как то сработало было всего два варианта: arecord и OBS.
### В чем была проблема arecord? 
Кое как подключившись спустя множество неудачных попыток с pipewire и pulseaudion я наконец то услышал звук. Звук был стабильный и не прирывистый, НО была большая задержка, а главное — с артефактами. Звук был как будто под эффектом замедления, это просто невозможно было использовать.
### В чем была проблема OBS? 
До этого все действия я делал на системе Orange Pi OS(Arch) и как оказалось поставить OBS на Arch это какой-то кошмар. Дошло до того что я сам билдил OBS из исходников, но по итогу сдался и поставил Debian. Почему Debian? Потому что на него можно поставить Pi Apps в котором спокойно установить OBS.
Теперь возникли другие проблемы. Чтобы стримить звук через OBS на основную машину пришлось на этой самой основной машине развернуть свой RTMP сервер для OBS.
#### Что это дало? 
По большей части ничего. Железо мини-ПК не справлялось с кодировщиком, из-за чего стрим прерывался и была большая задержка. Я бы посоветовал вариант с OBS, если у вас достаточно мощный мини-ПК, хотя я не особо уверен в этом варианте с точки зрения производительности для основной машины, ведь сервер разворачивается на ней.

## 4. Что сработало у меня?
В ходе некоторых тестов выяснилось что даже если я успешно транслирую звук по UDP то основная машина не может это обработать. Я пытался обрабатывать звук на основной машине через ffmpeg, как оказалось в этом и была основная проблема. До этого я много раз пытался обрабатывать разными способами звук через ffmpeg, но это не работало. Причину по которой ffmpeg не принимал UDP я так и не нашел.
В конечном итоге на основе проведенных тестов сети, других способов дублирования звука я поросил нейронку склепать прогу которая не будет использовать то, что раньше не дало никаких результатов. На удивление мне почти сразу дали готовое решение.

Linux
```
import socket
import subprocess

HOST = "192.168.0.1"  # Замените на ip вашего Windows
PORT = 50500

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

parec_cmd = [
    "parec",
    "--format=s16le",  # 16-bit PCM
    "--rate=44100",    # 44.1 kHz
    "--channels=2"     # Стерео
]

proc = subprocess.Popen(parec_cmd, stdout=subprocess.PIPE)

print(f"Streaming audio to {HOST}:{PORT} ...")

try:
    while True:
        data = proc.stdout.read(4096)
        if not data:
            break
        sock.sendto(data, (HOST, PORT))
except KeyboardInterrupt:
    print("Stopped by user")
finally:
    proc.terminate()
    sock.close()
```

Windows
```
# udp_audio_receiver.py
import socket
import sounddevice as sd
import numpy as np

HOST = "0.0.0.0"  # слушаем все интерфейсы
PORT = 50500       # должен совпадать с Linux

CHANNELS = 2
RATE = 44100
SAMPLE_WIDTH = 2  # байт, s16le

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((HOST, PORT))

print(f"Listening for audio on UDP {PORT}...")

stream = sd.OutputStream(
    samplerate=RATE,
    channels=CHANNELS,
    dtype='int16',
    blocksize=1024
)
stream.start()

try:
    while True:
        data, addr = sock.recvfrom(4096)
        audio = np.frombuffer(data, dtype=np.int16)
        if CHANNELS == 2:
            audio = audio.reshape(-1, 2)
        stream.write(audio)

except KeyboardInterrupt:
    print("Stopped by user")

finally:
    stream.stop()
    stream.close()
    sock.close()
```

Данный метод мне очень помог, он почти не имеет задержки и имеет хорошее качество звука.
Думаю если подключить мини ПК по Ethernet, а не по WiFi то небольшие артефакты звука и задержка вовсе пропадут.

# 5. Итог
Если собираетесь повторить то же, что и я, могу дать пару советов.
- Проверяйте аудио устройства на Linux, вы можете указать не то или с ними могут возникнуть другие проблемы.
- Проверяйте порты.
- Проверяйте как идут пакеты, доходят ли они вообще до Windows.
- Выбирайте способ под себя и свое железо, я определенно затронул не все способы.
- Обращайте внимание на кодировщики и формат, в котором отправляете звук, с этим могут быть проблемы

На серьёзную статью не тянет, но как небольшая выжимка того, как можно дублировать звук с Linux на Windows, думаю, неплохо.

P.S. Возможно буду дополнять этот текст. Способ который использую я хоть и хорошь, но имеет проблемы. Звук порой просто прерывается, скорее всего это из за того что мини-ПК использует WiFi. В любом случае я попробую решить эту проблему.
